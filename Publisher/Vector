#ifndef __VECTOR_H__
#define __VECTOR_H__

#include <vector>
#include <initializer_list>
#include "Types"

template<typename T>
class Vector : public std::vector<T> {
public:
    explicit Vector() : m_vector() { }
    explicit Vector(index n) : m_vector(n) { }
    Vector(const Vector &v) : m_vector(v.m_vector) { }
    Vector(std::initializer_list<T> init) : m_vector(init) { }

    index size() const { return m_vector.size(); }
    void resize(index n) { m_vector.resize(n); }
    void clear() { m_vector.clear(); }
    bool empty() const { return m_vector.empty(); }

    T &operator[](index i) { return m_vector[i]; }
    const T &operator[](index i) const { return m_vector[i]; }

    void append(const T &e) { m_vector.push_back(e); }
    void prepend( const T &e) { m_vector.insert(m_vector.begin(), e); }

    // Arithimetics

    Vector &operator*=(scalar s) {
        for (auto &e : m_vector)
            e *= s;
        return *this;
    }

    Vector &operator/=(scalar s) {
        for (auto &e : m_vector)
            e /= s;
        return *this;
    }

    Vector &operator+=(const Vector &v) {
        assert(size() == v.size());
        auto i1 = m_vector.begin();
        auto i2 = v.m_vector.begin();
        auto end1 = m_vector.end();
        auto end2 = v.m_vector.end();
        for ( ; (i1 != end1) and (i2 != end2); ++i1, ++i2)
            *i1 += *i2;
        return *this;
    }

    Vector &operator-=(const Vector &v) {
        assert(size() == v.size());
        auto i1 = m_vector.begin();
        auto i2 = v.m_vector.begin();
        auto end1 = m_vector.end();
        auto end2 = v.m_vector.end();
        for ( ; (i1 != end1) and (i2 != end2); ++i1, ++i2)
            *i1 -= *i2;
        return *this;
    }

    friend bool null(const Vector &v) {
        if (v.empty())
            return true;
        for (auto &e : v.m_vector)
            if ( !equal(e, 0) )
                return false;
        return true;
    }

    friend scalar abs(const Vector &v) {
        if (v.empty())
            return 0;
        scalar s = 0;
        for (auto &e : v.m_vector)
            s += e*e;
        return std::sqrt(s);
    }

    friend Vector unit(const Vector &v) {
        return v/abs(v);
    }

    friend bool operator!=(const Vector &v1, const Vector &v2) {
        assert(v1.size() == v2.size());
        auto i1 = v1.m_vector.begin();
        auto i2 = v2.m_vector.begin();
        auto end1 = v1.m_vector.end();
        auto end2 = v2.m_vector.end();
        for ( ; (i1 != end1) and (i2 != end2); ++i1, ++i2)
            if (*i1 == *i2)
                return false;
        return true;
    }

    friend bool operator==(const Vector &v1, const Vector &v2) {
        assert(v1.size() == v2.size());
        auto i1 = v1.m_vector.begin();
        auto i2 = v2.m_vector.begin();
        auto end1 = v1.m_vector.end();
        auto end2 = v2.m_vector.end();
        for ( ; (i1 != end1) and (i2 != end2); ++i1, ++i2)
            if (*i1 != *i2)
                return false;
        return true;
    }

    friend Vector operator/(const Vector &v, scalar s) {
        if (v.empty())
            return Vector();
        auto u = v;
        u /= s;
        return u;
    }

    friend Vector operator*(const Vector &v, scalar s) {
        if (v.empty())
            return Vector();
        auto u = v;
        u *= s;
        return u;
    }

    friend Vector operator*(scalar s, const Vector &v) {
        return v * s;
    }

    friend Vector operator+(const Vector &v) {
        return v;
    }

    friend Vector operator-(const Vector &v) {
        auto u = v;
        u *= -1;
        return u;
    }

    friend Vector operator+(const Vector &v1, const Vector &v2) {
        auto u = v1;
        u += v2;
        return u;
    }

    friend Vector operator-(const Vector &v1, const Vector &v2) {
        auto u = v1;
        u -= v2;
        return u;
    }

    // IO
    template<typename O> friend O &operator<<(O &o, const Vector &p) {
        for (const auto &e : p.m_vector)
            o << e << " ";
        return o;
    }

    template<typename I> friend I &operator>>(I &i, Vector &p) {
        for (auto &e : p.m_vector)
            i >> e;
        return i;
    }

private:

    std::vector<T> m_vector;
};

#endif
